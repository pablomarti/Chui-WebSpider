.\" Automatically generated by Pod::Man 2.16 (Pod::Simple 3.05)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Thread::Resource::RWLock 3"
.TH Thread::Resource::RWLock 3 "2012-02-24" "perl v5.10.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Thread::Resource::RWLock \- read/write lock base class for Perl ithreads
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&        package LockedObject;
\&
\&        use threads;
\&        use threads::shared;
\&        use Thread::Queue::Queueable;
\&        use Thread::Resource::RWLock;
\&
\&        use base qw(Thread::Queue::Queueable Thread::Resource::RWLock);
\&
\&        sub new {
\&                my $class = shift;
\&
\&                my %obj : shared = ();
\&
\&                my $self = bless \e%obj, $class;
\&        #
\&        #       init the locking members
\&        #
\&                $self\->Thread::Resource::RWLock::adorn();
\&                return $self;
\&        }
\&
\&        sub redeem {
\&                my ($class, $self);
\&
\&                return bless $self, $class;
\&        }
\&
\&        package main;
\&        use threads;
\&        use threads::shared;
\&        use Thread::Queue::Duplex;
\&        use LockedObject;
\&        #
\&        #       in threaded app:
\&        #
\&        my $read_write = LockedObject\->new();
\&        my $tqd = Thread::Queue::Duplex\->new();
\&        my $thrdA = threads\->new(\e&read_thread, $tqd);
\&        my $thrdB = threads\->new(\e&write_thread, $tqd);
\&        #
\&        # pass the shared object to each thread
\&        #
\&        $tqd\->enqueue_and_wait($read_write);
\&        $tqd\->enqueue_and_wait($read_write);
\&
\&        # Reader
\&        sub read_thread {
\&                my $tqd = shift;
\&                my $request = $tqd\->dequeue();
\&                $tqd\->respond($request\->[0], 1);
\&                my $obj = $request\->[1];
\&
\&                my $locktoken = $obj\->read_lock();
\&        #
\&        #       do some stuff
\&        #
\&                $obj\->unlock($locktoken);
\&        }
\&
\&        # Writer
\&        sub write_thread {
\&                my $tqd = shift;
\&                my $request = $tqd\->dequeue();
\&                $tqd\->respond($request\->[0], 1);
\&                my $obj = $request\->[1];
\&        #
\&        #       first grab a readlock
\&        #
\&                my $locktoken = $obj\->read_lock();
\&        #
\&        #       do some stuff, then upgrade to a writelock
\&        #
\&                $obj\->write_lock();
\&        #
\&        #       do some stuff, then unlock
\&        #
\&                $obj\->unlock($locktoken);
\&        }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Thread::Resource::RWLock provides both an inheritable abstract class,
as well as a concrete object implementation, to regulate concurrent
access to resources.
Multiple concurrent reader threads may hold a Thread::Resource::RWLock
readlock at the same time, while a single writer thread holds the lock
exclusively.
.PP
New reader threads are blocked if any writer is currently waiting to
obtain the lock. The read lock is granted after all pending write lock
requests have been released.
.PP
Thread::Resource::RWLock accomodates a thread which already holds
a lock and then requests another lock on the resource, as follows:
.IP "\fBno lock held, requests readlock\fR" 4
.IX Item "no lock held, requests readlock"
Lock is granted when any pending writelock requests
are applied, and then released. Returned value is a unique
locktoken value.
.IP "\fBno lock held, requests writelock\fR" 4
.IX Item "no lock held, requests writelock"
Lock is granted when any current readlocks
are released. If multiple writelock requests are pending,
the writelock will be granted in a random fashion.
Returned value is a unique locktoken value.
.IP "\fBholds readlock, requests readlock\fR" 4
.IX Item "holds readlock, requests readlock"
The lock level remains the same, but the returned value
is \-1, indicating a lock was already held.
.IP "\fBholds readlock, requests writelock\fR" 4
.IX Item "holds readlock, requests writelock"
The lock level is upgraded to write when all other
readers have unlocked, and the returned value
is \-1, indicating a lock was already held.
.IP "\fBholds writelock, requests readlock\fR" 4
.IX Item "holds writelock, requests readlock"
The lock level is downgraded to read, regardless
if any other writelock requests are pending.
The returned value is \-1, indicating a lock was
already held.
.IP "\fBholds writelock, requests writelock\fR" 4
.IX Item "holds writelock, requests writelock"
The lock level remains the same, but the returned value
is \-1, indicating a lock was already held.
.PP
In addition, both nonblocking and timed interfaces are
provided to permit acquiring a lock only if the lock can be granted
immediately, or within a specified number of seconds. If the lock
is \fBnot\fR granted, the returned value is \f(CW\*(C`undef\*(C'\fR.
.PP
This implementation provides 2 constructors:
the usual \f(CW\*(C`new()\*(C'\fR method which constructs a shared object instance,
suitable for use as a member of a shared object,
and an \f(CW\*(C`adorn()\*(C'\fR method for classes which subclass Thread::Resource::RWLock.
.PP
Finally, note that this implementation supports both array and hash
based objects. \fIArray-based subclasses should reserve the first 4 entries
in their array for the Thread::Resource::RWLock member variables.\fR
.PP
\fILocks Do Not Accumulate\fR
.IX Subsection "Locks Do Not Accumulate"
.PP
The application is responsible for tracking and preserving lock consistency
when it repeatedly requests locks on a resource for which it already
holds locks. In support of this, Thread::Resource::RWLock's lock methods
return a positive locktoken value when the lock is initially granted
(the timestamp returned by Time::HiRes::\fItime()\fR), and returns \-1 when a
thread is granted a lock on a resource on which it already holds a lock.
.PP
The \f(CW\*(C`unlock()\*(C'\fR method takes a single (optional) \f(CW$locktoken\fR parameter.
If the \f(CW$locktoken\fR matches the locktoken returned when the thread was originally
locked, then the lock will be released; otherwise, the \f(CW\*(C`unlock()\*(C'\fR is ignored,
and the lock will continue to be held. If no \f(CW$locktoken\fR parameter is provided,
then the unlock is applied unconditionally.
.SH "METHODS"
.IX Header "METHODS"
.IP "adorn" 8
.IX Item "adorn"
Adorns the input resource object with Thread::Resource::RWLock object
member variables in an unlocked state.
.IP "new" 8
.IX Item "new"
Creates a new concrete instance of an unlocked Thread::Resource::RWLock object.
.ie n .IP "\fI\fI$locktoken\fI\fR = \fI\f(CI$resource\fI\->\fR\fB\f(BIread_lock()\fB\fR" 8
.el .IP "\fI\f(CI$locktoken\fI\fR = \fI\f(CI$resource\fI\->\fR\fB\f(BIread_lock()\fB\fR" 8
.IX Item "$locktoken = $resource->read_lock()"
Requests a read lock. If another thread currently
holds a writelock on the resource, \f(CW\*(C`read_lock\*(C'\fR blocks
until all pending writelock requests have been released.
If the requesting thread holds a writelock on the resource,
the lock is downgraded to a readlock, without granting the writelock
to any pending requestors. Returned value is Time::HiRes::\fItime()\fR
if the requestor did not already hold a lock on the resource, or \-1
if it did.
.ie n .IP "\fI\fI$locktoken\fI\fR = \fI\f(CI$resource\fI\->\fR\fB\f(BIread_lock_nb()\fB\fR" 8
.el .IP "\fI\f(CI$locktoken\fI\fR = \fI\f(CI$resource\fI\->\fR\fB\f(BIread_lock_nb()\fB\fR" 8
.IX Item "$locktoken = $resource->read_lock_nb()"
Same as \f(CW\*(C`read_lock()\*(C'\fR, except it returns immediately without
granting the readlock if the resource is currently writelocked by another
thread. Returns \f(CW\*(C`undef\*(C'\fR if the lock cannot be granted immediately,
Time::HiRes::\fItime()\fR if the lock is granted and the requestor did not
already hold a lock on the resource, or \-1 if it did hold a lock.
.ie n .IP "\fI\fI$locktoken\fI\fR = \fI\f(CI$resource\fI\->\fR\fBread_lock_timed\fR \fI($timeout)\fR" 8
.el .IP "\fI\f(CI$locktoken\fI\fR = \fI\f(CI$resource\fI\->\fR\fBread_lock_timed\fR \fI($timeout)\fR" 8
.IX Item "$locktoken = $resource->read_lock_timed ($timeout)"
Same as \f(CW\*(C`read_lock()\*(C'\fR, except it returns \f(CW\*(C`undef\*(C'\fR if the readlock is
not granted within \f(CW$timeout\fR seconds.
Returns Time::HiRes::\fItime()\fR if the lock is granted and the requestor did not
already hold a lock on the resource, or \-1 if it did.
.ie n .IP "\fI\fI$locktoken\fI\fR = \fI\f(CI$resource\fI\->\fR\fB\f(BIwrite_lock()\fB\fR" 8
.el .IP "\fI\f(CI$locktoken\fI\fR = \fI\f(CI$resource\fI\->\fR\fB\f(BIwrite_lock()\fB\fR" 8
.IX Item "$locktoken = $resource->write_lock()"
Requests a writelock on the resource. Writelocks are exclusive, so no
other readers or writers are granted access until the writelock is released.
Note that a thread may be granted the writelock if the
resource is currently only readlocked by the requesting thread
(i.e., the thread is requesting a lock upgrade).
\&\f(CW\*(C`write_lock()\*(C'\fR blocks until the lock is available.
Returns Time::HiRes::\fItime()\fR if the lock is granted and the requestor did not
already hold a lock on the resource, or \-1 if it did hold a lock.
.ie n .IP "\fI\fI$locktoken\fI\fR = \fI\f(CI$resource\fI\->\fR\fB\f(BIwrite_lock_nb()\fB\fR" 8
.el .IP "\fI\f(CI$locktoken\fI\fR = \fI\f(CI$resource\fI\->\fR\fB\f(BIwrite_lock_nb()\fB\fR" 8
.IX Item "$locktoken = $resource->write_lock_nb()"
Same as \f(CW\*(C`write_lock()\*(C'\fR, but returns \f(CW\*(C`undef\*(C'\fR immediately if the
writelock cannot be granted (i.e., another thread holds
a read or write lock on the resource).
Returns Time::HiRes::\fItime()\fR if the lock is granted and the requestor did not
already hold a lock on the resource, or \-1 if it did hold a lock.
.ie n .IP "\fI\fI$locktoken\fI\fR = \fI\f(CI$resource\fI\->\fR\fBwrite_lock_timed\fR\fI($timeout)\fR" 8
.el .IP "\fI\f(CI$locktoken\fI\fR = \fI\f(CI$resource\fI\->\fR\fBwrite_lock_timed\fR\fI($timeout)\fR" 8
.IX Item "$locktoken = $resource->write_lock_timed($timeout)"
Same as \f(CW\*(C`write_lock()\*(C'\fR, but returns \f(CW\*(C`undef\*(C'\fR if the
write lock cannot be granted within \f(CW$timeout\fR seconds
Returns Time::HiRes::\fItime()\fR if the lock is granted and the requestor did not
already hold a lock on the resource, or \-1 if it did hold a lock.
.ie n .IP "\fI\fI$result\fI\fR = \fI\f(CI$resource\fI\->\fR\fBunlock\fR\fI( [ \f(CI$locktoken\fI ] )\fR" 8
.el .IP "\fI\f(CI$result\fI\fR = \fI\f(CI$resource\fI\->\fR\fBunlock\fR\fI( [ \f(CI$locktoken\fI ] )\fR" 8
.IX Item "$result = $resource->unlock( [ $locktoken ] )"
Releases a lock held by the requesting thread.
If a \f(CW$locktoken\fR is provided, it must match the original
token returned when the requesting thread was granted the lock.
If \f(CW$locktoken\fR is not provided, the lock is released unconditionally.
\&\f(CW$result\fR is 1 if the lock is released, or undef if the lock is retained.
.SH "CAVEATS"
.IX Header "CAVEATS"
.IP "\fBDifferences from\fR Thread::RWLock" 4
.IX Item "Differences from Thread::RWLock"
Thread::Resource::RWLock provides a significantly different
interface than Thread::RWLock. Most importantly, the latter
uses the old Perl 5.005 Thread module, and depends on its
\&\f(CW\*(C`locked\*(C'\fR method attribute. In addition, Thread::RWLock's
interface
.Sp
.Vb 1
\&        \- uses somewhat obscure method names (up_read, down_write, etc.)
\&
\&        \- does not support lock upgrades and downgrades
\&
\&        \- hence, can lead to deadlock, if a thread holding
\&                a readlock attempts to upgrade to a writelock,
\&                or attempts to downgrade to a readlock from a writelock
\&
\&        \- accumulates readlocks from the same thread, thereby
\&                requiring multple unlock() calls to completely
\&                release a resource which has been repeatedly readlocked
\&
\&        \- does not support a subclassing capability
.Ve
.IP "\fBStarvation\fR" 4
.IX Item "Starvation"
Due to the ability to upgrade/downgrade locks, it is possible
for starvation to occur, wherein a thread waiting on a write lock
may be indefinitely blocked while another thread repeatedly upgrades,
then downgrades its lock without ever releasing the lock. Use of
lock upgrade/downgrade should be applied judiciously.
.Sp
Multiple readers concurrently attempting to upgrade to writelocks
can also induce deadlock (since the readlocker count will never
drop to 1). A future release may provide an upgrade queue to handle
this case.
.IP "\fBZone Threading\fR" 4
.IX Item "Zone Threading"
Applications using Thread::Apartment to support zone threading
(i.e., multiple objects installed in a single apartment thread)
may need to implement extra locking functionality if the objects
within the thread are sharing the same resource in read and write
modes, as Thread::Resource::RWLock relies on the current
\&\s-1TID\s0 (via threads::\fItid()\fR) to disambiguate lockers of the same
resource. If all objects within the thread are using only readlocks,
there should be no impact. However, multiple objects using write locks,
or attempting upgrades or downgrades of locks, may cause unexpected
behavior, including deadlock or indeterminate values. Therefore,
best practice would be to segregate resource writers in their own
apartment thread. A future implementation may provide a
Thread::Resource::Locker interface which Thread::Apartment objects
can implement to disambiguate co-resident zone threaded objects.
.IP "\fBContext Accumulation\fR" 4
.IX Item "Context Accumulation"
In the event a thread holding a lock exits without explicitly
\&\fIunlock()\fR'ing, the lock will be retained until the resource
object is \s-1DESTROY\s0'ed, resulting in dead context accumulation,
deadlock, and/or starvation. A future release may inject an
occassional timer event to verify lock holders are still
running.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
threads
.PP
threads::shared
.PP
Thread::RWLock
.PP
Thread::Semaphore
.SH "AUTHOR AND COPYRIGHT"
.IX Header "AUTHOR AND COPYRIGHT"
Copyright (c) 2005 Dean Arnold, Presicient Corp, \s-1USA\s0. All rights reserved.
.PP
Permission to use and redistirbute this software is granted under the same
terms as Perl itself; refer to perlartistic for license details.
