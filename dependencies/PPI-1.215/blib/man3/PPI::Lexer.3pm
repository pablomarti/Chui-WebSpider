.\" Automatically generated by Pod::Man 2.16 (Pod::Simple 3.05)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PPI::Lexer 3"
.TH PPI::Lexer 3 "2011-02-26" "perl v5.10.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
PPI::Lexer \- The PPI Lexer
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use PPI;
\&  
\&  # Create a new Lexer
\&  my $Lexer = PPI::Lexer\->new;
\&  
\&  # Build a PPI::Document object from a Token stream
\&  my $Tokenizer = PPI::Tokenizer\->load(\*(AqMy/Module.pm\*(Aq);
\&  my $Document = $Lexer\->lex_tokenizer($Tokenizer);
\&  
\&  # Build a PPI::Document object for some raw source
\&  my $source = "print \*(AqHello World!\*(Aq; kill(Humans\->all);";
\&  $Document = $Lexer\->lex_source($source);
\&  
\&  # Build a PPI::Document object for a particular file name
\&  $Document = $Lexer\->lex_file(\*(AqMy/Module.pm\*(Aq);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The is the \s-1PPI\s0 Lexer. In the larger scheme of things, its job is to take
token streams, in a variety of forms, and \*(L"lex\*(R" them into nested structures.
.PP
Pretty much everything in this module happens behind the scenes at this
point. In fact, at the moment you don't really need to instantiate the lexer
at all, the three main methods will auto-instantiate themselves a
\&\f(CW\*(C`PPI::Lexer\*(C'\fR object as needed.
.PP
All methods do a one-shot "lex this and give me a PPI::Document object".
.PP
In fact, if you are reading this, what you \fBprobably\fR want to do is to
just \*(L"load a document\*(R", in which case you can do this in a much more
direct and concise manner with one of the following.
.PP
.Vb 1
\&  use PPI;
\&  
\&  $Document = PPI::Document\->load( $filename );
\&  $Document = PPI::Document\->new( $string );
.Ve
.PP
See PPI::Document for more details.
.PP
For more unusual tasks, by all means forge onwards.
.SH "METHODS"
.IX Header "METHODS"
.Sh "new"
.IX Subsection "new"
The \f(CW\*(C`new\*(C'\fR constructor creates a new \f(CW\*(C`PPI::Lexer\*(C'\fR object. The object itself
is merely used to hold various buffers and state data during the lexing
process, and holds no significant data between \->lex_xxxxx calls.
.PP
Returns a new \f(CW\*(C`PPI::Lexer\*(C'\fR object
.ie n .Sh "lex_file $filename"
.el .Sh "lex_file \f(CW$filename\fP"
.IX Subsection "lex_file $filename"
The \f(CW\*(C`lex_file\*(C'\fR method takes a filename as argument. It then loads the file,
creates a PPI::Tokenizer for the content and lexes the token stream
produced by the tokenizer. Basically, a sort of all-in-one method for
getting a PPI::Document object from a file name.
.PP
Returns a PPI::Document object, or \f(CW\*(C`undef\*(C'\fR on error.
.ie n .Sh "lex_source $string"
.el .Sh "lex_source \f(CW$string\fP"
.IX Subsection "lex_source $string"
The \f(CW\*(C`lex_source\*(C'\fR method takes a normal scalar string as argument. It
creates a PPI::Tokenizer object for the string, and then lexes the
resulting token stream.
.PP
Returns a PPI::Document object, or \f(CW\*(C`undef\*(C'\fR on error.
.ie n .Sh "lex_tokenizer $Tokenizer"
.el .Sh "lex_tokenizer \f(CW$Tokenizer\fP"
.IX Subsection "lex_tokenizer $Tokenizer"
The \f(CW\*(C`lex_tokenizer\*(C'\fR takes as argument a PPI::Tokenizer object. It
lexes the token stream from the tokenizer into a PPI::Document object.
.PP
Returns a PPI::Document object, or \f(CW\*(C`undef\*(C'\fR on error.
.PP
# Validate the creation of a null statement
\&\s-1SCOPE:\s0 {
	my \f(CW$token\fR = new_ok( 'PPI::Token::Structure' => [ ')'    ] );
	my \f(CW$brace\fR = new_ok( 'PPI::Statement::UnmatchedBrace' => [ \f(CW$token\fR ] );
	is( \f(CW$brace\fR\->content, ')', '\->content ok' );
}
.PP
my \f(CW$document\fR = PPI::Document\->new(\e<<'\s-1END_PERL\s0');
use constant { One => 1 };
use constant 1 { One => 1 };
\&\f(CW$foo\fR\->{bar};
\&\f(CW$foo\fR[1]{bar};
\&\f(CW$foo\fR{bar};
sub {1};
grep { \f(CW$_\fR } 0 .. 2;
map { \f(CW$_\fR => 1 } 0 .. 2;
sort { \f(CW$b\fR <=> \f(CW$a\fR } 0 .. 2;
do {foo};
\&\f(CW$foo\fR = { One => 1 };
\&\f(CW$foo\fR ||= { One => 1 };
1, { One => 1 };
One => { Two => 2 };
{foo, bar};
{foo => bar};
{};
+{foo, bar};
{; => bar};
\&\f(CW@foo\fR{'bar', 'baz'};
@{$foo}{'bar', 'baz'};
${$foo}{bar};
return { foo => 'bar' };
bless { foo => 'bar' };
\&\s-1END_PERL\s0
.PP
isa_ok( \f(CW$document\fR, 'PPI::Document' );
\&\f(CW$document\fR\->\fIindex_locations()\fR;
.PP
my \f(CW@statements\fR;
foreach my \f(CW$elem\fR ( @{ \f(CW$document\fR\->find( 'PPI::Statement' ) || [] } ) {
	\f(CW$statements\fR[ \f(CW$elem\fR\->\fIline_number()\fR \- 1 ] ||= \f(CW$elem\fR;
}
.PP
is( scalar(@statements), 24, 'Found 24 statements' );
.PP
isa_ok( \f(CW$statements\fR[0]\->\fIschild\fR\|(2), 'PPI::Structure::Constructor',
	'The curly in ' . \f(CW$statements\fR[0]);
isa_ok( \f(CW$statements\fR[1]\->\fIschild\fR\|(3), 'PPI::Structure::Constructor',
	'The curly in ' . \f(CW$statements\fR[1]);
isa_ok( \f(CW$statements\fR[2]\->\fIschild\fR\|(2), 'PPI::Structure::Subscript',
	'The curly in ' . \f(CW$statements\fR[2]);
isa_ok( \f(CW$statements\fR[3]\->\fIschild\fR\|(2), 'PPI::Structure::Subscript',
	'The curly in ' . \f(CW$statements\fR[3]);
isa_ok( \f(CW$statements\fR[4]\->\fIschild\fR\|(1), 'PPI::Structure::Subscript',
	'The curly in ' . \f(CW$statements\fR[4]);
isa_ok( \f(CW$statements\fR[5]\->\fIschild\fR\|(1), 'PPI::Structure::Block',
	'The curly in ' . \f(CW$statements\fR[5]);
isa_ok( \f(CW$statements\fR[6]\->\fIschild\fR\|(1), 'PPI::Structure::Block',
	'The curly in ' . \f(CW$statements\fR[6]);
isa_ok( \f(CW$statements\fR[7]\->\fIschild\fR\|(1), 'PPI::Structure::Block',
	'The curly in ' . \f(CW$statements\fR[7]);
isa_ok( \f(CW$statements\fR[8]\->\fIschild\fR\|(1), 'PPI::Structure::Block',
	'The curly in ' . \f(CW$statements\fR[8]);
isa_ok( \f(CW$statements\fR[9]\->\fIschild\fR\|(1), 'PPI::Structure::Block',
	'The curly in ' . \f(CW$statements\fR[9]);
isa_ok( \f(CW$statements\fR[10]\->\fIschild\fR\|(2), 'PPI::Structure::Constructor',
	'The curly in ' . \f(CW$statements\fR[10]);
isa_ok( \f(CW$statements\fR[11]\->\fIschild\fR\|(3), 'PPI::Structure::Constructor',
	'The curly in ' . \f(CW$statements\fR[11]);
isa_ok( \f(CW$statements\fR[12]\->\fIschild\fR\|(2), 'PPI::Structure::Constructor',
	'The curly in ' . \f(CW$statements\fR[12]);
isa_ok( \f(CW$statements\fR[13]\->\fIschild\fR\|(2), 'PPI::Structure::Constructor',
	'The curly in ' . \f(CW$statements\fR[13]);
isa_ok( \f(CW$statements\fR[14]\->\fIschild\fR\|(0), 'PPI::Structure::Block',
	'The curly in ' . \f(CW$statements\fR[14]);
isa_ok( \f(CW$statements\fR[15]\->\fIschild\fR\|(0), 'PPI::Structure::Constructor',
	'The curly in ' . \f(CW$statements\fR[15]);
isa_ok( \f(CW$statements\fR[16]\->\fIschild\fR\|(0), 'PPI::Structure::Constructor',
	'The curly in ' . \f(CW$statements\fR[16]);
isa_ok( \f(CW$statements\fR[17]\->\fIschild\fR\|(1), 'PPI::Structure::Constructor',
	'The curly in ' . \f(CW$statements\fR[17]);
isa_ok( \f(CW$statements\fR[18]\->\fIschild\fR\|(0), 'PPI::Structure::Block',
	'The curly in ' . \f(CW$statements\fR[18]);
isa_ok( \f(CW$statements\fR[19]\->\fIschild\fR\|(1), 'PPI::Structure::Subscript',
	'The curly in ' . \f(CW$statements\fR[19]);
isa_ok( \f(CW$statements\fR[20]\->\fIschild\fR\|(2), 'PPI::Structure::Subscript',
	'The curly in ' . \f(CW$statements\fR[20]);
isa_ok( \f(CW$statements\fR[21]\->\fIschild\fR\|(2), 'PPI::Structure::Subscript',
	'The curly in ' . \f(CW$statements\fR[21]);
isa_ok( \f(CW$statements\fR[22]\->\fIschild\fR\|(1), 'PPI::Structure::Constructor',
	'The curly in ' . \f(CW$statements\fR[22]);
isa_ok( \f(CW$statements\fR[23]\->\fIschild\fR\|(1), 'PPI::Structure::Constructor',
	'The curly in ' . \f(CW$statements\fR[23]);
.PP
# Validate the creation of a null statement
\&\s-1SCOPE:\s0 {
	my \f(CW$token\fR = new_ok( 'PPI::Token::Structure' => [ ';'    ] );
	my \f(CW$null\fR  = new_ok( 'PPI::Statement::Null'  => [ \f(CW$token\fR ] );
	is( \f(CW$null\fR\->content, ';', '\->content ok' );
}
.PP
# Validate the creation of an empty statement
new_ok( 'PPI::Statement' => [ ] );
.Sh "errstr"
.IX Subsection "errstr"
For any error that occurs, you can use the \f(CW\*(C`errstr\*(C'\fR, as either
a static or object method, to access the error message.
.PP
If no error occurs for any particular action, \f(CW\*(C`errstr\*(C'\fR will return false.
.SH "TO DO"
.IX Header "TO DO"
\&\- Add optional support for some of the more common source filters
.PP
\&\- Some additional checks for blessing things into various Statement
and Structure subclasses.
.SH "SUPPORT"
.IX Header "SUPPORT"
See the support section in the main module.
.SH "AUTHOR"
.IX Header "AUTHOR"
Adam Kennedy <adamk@cpan.org>
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 2001 \- 2011 Adam Kennedy.
.PP
This program is free software; you can redistribute
it and/or modify it under the same terms as Perl itself.
.PP
The full text of the license can be found in the
\&\s-1LICENSE\s0 file included with this module.
.SH "POD ERRORS"
.IX Header "POD ERRORS"
Hey! \fBThe above document had some coding errors, which are explained below:\fR
.IP "Around line 250:" 4
.IX Item "Around line 250:"
\&'=begin' only takes one parameter, not several as in '=begin testing _lex_document 3'
.IP "Around line 259:" 4
.IX Item "Around line 259:"
=end testing without matching =begin.  (Stack: [empty])
.IP "Around line 1089:" 4
.IX Item "Around line 1089:"
\&'=begin' only takes one parameter, not several as in '=begin testing _curly 26'
.IP "Around line 1177:" 4
.IX Item "Around line 1177:"
=end testing without matching =begin.  (Stack: [empty])
.IP "Around line 1296:" 4
.IX Item "Around line 1296:"
\&'=begin' only takes one parameter, not several as in '=begin testing _lex_structure 4'
.IP "Around line 1308:" 4
.IX Item "Around line 1308:"
=end testing without matching =begin.  (Stack: [empty])
