.\" Automatically generated by Pod::Man 2.16 (Pod::Simple 3.05)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Data::Inspect 3"
.TH Data::Inspect 3 "2010-03-14" "perl v5.10.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Data::Inspect \- human\-readable object representations
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\&  use Data::Inspect;
\&  my $insp = Data::Inspect\->new;
\&  $insp\->p($object);
\&
\&  use Data::Inspect qw(p);
\&  p $object;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Data::Inspect provides a human-readable representation of any Perl
scalar. Classes can be extended with user-defined inspect methods. It
is heavily inspired by Ruby's \f(CW\*(C`p\*(C'\fR method and inspect functionality.
.PP
The purpose of this module is to provide debugging/logging code with a
more readable representation of data structures than the extremely
literal form output by Data::Dumper.
.PP
It is especially useful in an object-oriented system, since each class
can define its own \f(CW\*(C`inspect\*(C'\fR method, indicating how that particular
object should be displayed.
.PP
The \*(L"p\*(R" method inspects its arguments and outputs them to the default
filehandle. It can be exported to your package's namespace, in which
case it will silently create the Inspect object with the default
options, if this sort of brevity is desired.
.SH "PUBLIC METHODS"
.IX Header "PUBLIC METHODS"
.IP "new" 4
.IX Item "new"
.Vb 1
\&  my $insp = Data::Inspect\->new;
.Ve
.Sp
Create a new Data::Inspect object.
.IP "p" 4
.IX Item "p"
.Vb 1
\&  $insp\->p($var1, $var2);
\&
\&  use Data::Inspect qw(p);
\&  p $var1, $var2;
.Ve
.Sp
Inspects each of the provided arguments and outputs the result to the
default filehandle (usually \s-1STDOUT\s0).
.Sp
\&\f(CW\*(C`p\*(C'\fR can be exported to the current namespace if you don't want to
create a Data::Inspect object to do your inspecting for you.
.IP "pe" 4
.IX Item "pe"
.Vb 1
\&  $insp\->pe($var1, $var2);
.Ve
.Sp
Exactly like \*(L"p\*(R" but outputs to \s-1STDERR\s0 instead of the default
filehandle.
.IP "pf" 4
.IX Item "pf"
.Vb 1
\&  $insp\->pf($somefh, $var1, $var2);
.Ve
.Sp
Like \*(L"p\*(R" and \*(L"pe\*(R" but outputs to the filehandle specified in the
first argument.
.Sp
Note that the filehandle must be a reference. If you want to use a
filehandle that isn't a reference, you can create one using the
Symbol::qualify_to_ref function.
.IP "inspect" 4
.IX Item "inspect"
.Vb 1
\&  my $value = $insp\->inspect($var);
.Ve
.Sp
Inspects the given scalar value and returns the result.
.IP "set_option" 4
.IX Item "set_option"
.Vb 1
\&  $insp\->set_option(\*(Aqtruncate_strings\*(Aq, 30);
.Ve
.Sp
Set the given option to the given value. Options alter the output of
Inspect.
.Sp
Available options are:
.RS 4
.IP "truncate_strings" 4
.IX Item "truncate_strings"
If set to a positive integer, truncates strings after that number of
characters, replacing the end with '...'.
.Sp
default: undef
.IP "sort_keys" 4
.IX Item "sort_keys"
If set to the string 'cmp' or '<=>', hashes will have their keys
sorted using the specified comparison before being output.
.Sp
default: undef
.RE
.RS 4
.RE
.SH "EXAMPLES"
.IX Header "EXAMPLES"
.Sh "Inspecting built-in Perl types"
.IX Subsection "Inspecting built-in Perl types"
In this example, we use the \*(L"p\*(R" method to output the inspected contents
of a Perl hash:
.PP
.Vb 2
\&  use Data::Inspect qw(p);
\&  p \e%some_hash;
.Ve
.PP
The output is something like:
.PP
.Vb 1
\&  {"baz" => "qux\en\en", "foo" => "bar"}
.Ve
.Sh "Changing how an object looks"
.IX Subsection "Changing how an object looks"
In this example, objects of class \f(CW\*(C`Wibble\*(C'\fR are blessed hashrefs
containing a lot of data. They are uniquely identifiable by one key,
\&\f(CW\*(C`id\*(C'\fR; so we create an inspect method that just displays that \f(CW\*(C`id\*(C'\fR:
.PP
.Vb 1
\&  package Wibble;
\&  
\&  sub inspect {
\&    my ($self, $insp) = @_;
\&    "#<Wibble id=$self\->{id}>";
\&  }
.Ve
.PP
If we have a hash full of Wibbles we can now see its contents easily
by inspecting it:
.PP
.Vb 2
\&  use Data::Inspect qw(p);
\&  p \e%hash_of_wibbles;
.Ve
.PP
The output will be something like:
.PP
.Vb 1
\&  {"bar" => #<Wibble id=42>, "baz" => #<Wibble id=667>, "foo" => #<Wibble id=1>}
.Ve
.Sh "Recursive inspecting"
.IX Subsection "Recursive inspecting"
\&\f(CW$_\fR[1] is set to the current Data::Inspect object in calls to an
object's \f(CW\*(C`inspect\*(C'\fR method. This allows you to recursively inspect
data structures contained within the object, such as hashes:
.PP
.Vb 1
\&  package Wibble;
\&
\&  sub inspect {
\&    my ($self, $insp) = @_;
\&    "#<Wibble id=$self\->{id} data=".$insp\->inspect($self\->{data}).">";
\&  }
.Ve
.Sh "Using Data::Inspect in the \s-1OO\s0 form"
.IX Subsection "Using Data::Inspect in the OO form"
The \s-1OO\s0 form provides a greater degree of flexibility than just
importing the \*(L"p\*(R" method. The behaviour of Data::Inspect can be
modified using the \*(L"set_option\*(R" method and there is also an
\&\*(L"inspect\*(R" method that returns the inspected form rather than
outputting it.
.PP
.Vb 2
\&  use Data::Inspect;
\&  my $insp = Data::Inspect\->new;
\&  
\&  # Strings are truncated if they are more than 10 characters long
\&  $insp\->set_option(\*(Aqtruncate_strings\*(Aq, 10);
\&  
\&  $insp\->p("Supercalifragilisticexpialidocious");
.Ve
.PP
Outputs:
.PP
.Vb 1
\&  "Supercalif..."
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Data::Dumper
.PP
The Ruby documentation for \f(CW\*(C`Object#inspect\*(C'\fR and \f(CW\*(C`Kernel#p\*(C'\fR at
http://www.ruby\-doc.org/core/
.SH "CHANGES"
.IX Header "CHANGES"
.Vb 1
\&  \- 0.04 Fixed test case 7 to work with Perl 5.11.5
\&
\&  \- 0.03 Fixed documentation and tests further.
\&
\&  \- 0.02 Added support and documentation for recursive inspecting.
\&         Fixed tests on versions of perl built without useperlio.
\&
\&  \- 0.01 Initial revision
.Ve
.SH "AUTHOR"
.IX Header "AUTHOR"
Rich Daley <cpan@owl.me.uk>
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 2009 Rich Daley. All rights reserved.
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.
